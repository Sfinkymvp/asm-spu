#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "asm.h"
#include "asm_data.h"


const char* error_messages[] = {
    "This message should not be printed",
    "Failed to open file",
    "Failed to read data from file",
    "Failed to write data to file",
    "Failed to close file",
    "Unknown command line argument",
    "Unknown processor instruction",
    "Failed to allocate memory"};


ErrorCode assembler(ByteCode* code, char* buffer)
{
    assert(code != NULL);
    assert(buffer != NULL);

    initializeByteCode(code, START_CAPACITY);

    char instruction[MAX_INSTRUCTION_LEN + 1] = "";
    char* token = strtok(buffer, "\n");
    size_t index = 0;
    ErrorCode error_code = ERR_OK;

    while (token != NULL && error_code == ERR_OK) {
        if (index >= code->capacity - 1)
            error_code = expandByteCode(code);

        if (error_code != ERR_OK)
            break;
        error_code = assembleInstruction(code, token, instruction, &index);

        token = strtok(NULL, "\n");
    }

    if (error_code != ERR_OK) {
        free(code->data);
        code->data = NULL;
        return error_code;
    }

    return ERR_OK;
}


ErrorCode assembleInstruction(ByteCode* code, char* substring, char* instruction, size_t* index)
{
    assert(code != NULL);
    assert(substring != NULL);
    assert(instruction != NULL);
    assert(index != NULL);

    if (sscanf(substring, "%4s", instruction) != 1) {
        return ERR_INVALID_INSTRUCTION;
    }

    ErrorCode err = ERR_OK;

    if (strcmp(instruction, "HLT") == 0) {
        code->data[*index] = (int)CMD_HLT;
    else if (strcmp(instruction, "PUSH") == 0) {
        err = asmPushValue(code, substring, index);
        if (err != ERR_OK)
            return err;
    } else if (strcmp(instruction, "ADD") == 0) {
        code->data[*index] = (int)CMD_ADD;
    } else if (strcmp(instruction, "SUB") == 0) {
        code->data[*index] = (int)CMD_SUB;
    } else if (strcmp(instruction, "DIV") == 0) {
        code->data[*index] = (int)CMD_DIV;
    } else if (strcmp(instruction, "MUL") == 0) {
        code->data[*index] = (int)CMD_MUL;
    } else if (strcmp(instruction, "SQRT") == 0) {
        code->data[*index] = (int)CMD_SQRT;
    } else if (strcmp(instruction, "PUSHR") == 0) {
        err = asmPushRegister(code, substring, index);
        if (err != ERR_OK)
            return err;
    } else if (strcmp(instruction, "POPR") == 0) {
        err = asmPopRegister(code, substring, index)
        if (err != ERR_OK)
            return err;
    } else if (strcmp(instruction, "IN") == 0) {
        err = asmInValue(code, substring, index);

    } else if (strcmp(instruction, "OUT") == 0) {
        code->data[*index] = (int)CMD_OUT;
    } else {
        return ERR_INVALID_INSTRUCTION;
    }

    (*index)++;
    code->instruction_count++;
    return ERR_OK;
}


ErrorCode asmPushValue(ByteCode* code, const char* substring, int* value, size_t* index)
{
    assert(code != NULL);
    assert(code != NULL);
    assert(value != NULL);
    assert(index != NULL);

    if (sscanf(substring, "%*s %d", &value) != 1)
        return ERR_INVALID_INSTRUCTION;

    code->data[*index] = (int)CMD_PUSH;
    code->data[++*index] = value;
    code->instruction_count++;
    return ERR_OK;
}


ErrorCode initializeByteCode(ByteCode* code, size_t start_capacity)
{
    assert(code != NULL);

    code->data = (int*)calloc(start_capacity, sizeof(int));
    if (code->data == NULL)
        return ERR_OUT_OF_MEMORY;

    code->capacity = start_capacity;
    return ERR_OK;
}


ErrorCode expandByteCode(ByteCode* code)
{
    assert(code != NULL);

    void* temp = realloc(code->data, code->capacity * 2 * sizeof(int));
    if (temp == NULL)
        return ERR_OUT_OF_MEMORY;

    code->data = (int*)temp;
    code->capacity *= 2;
    return ERR_OK;
}


void destroyData(AssemblyData* data)
{
    assert(data != NULL);
   
    free(data->buffer);
    free(data->code.data);
}
